#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Global includes
#include <global_include.h>
#include <x1_include.h>

// Local Includes
#include "x1_state_machine.h"

// Func prototypes
void* sensor_send_thread(void*);
void* x1_message_server_thread(void*);
void x1_global_init(sm_data_t*);

int main(void) {
	printf("Begin X1 State Machine Node\n");

	// Initialise global variable
	sm_data_t global_data;
	x1_global_init(&global_data);

	// Create the threads
	pthread_t sensor_thread, state_machine_thread, state_machine_output_thread, msg_srv_thread;
	pthread_create(&sensor_thread, NULL, sensor_send_thread, &global_data);
	pthread_create(&state_machine_thread, NULL, x1_state_machine, &global_data);
	pthread_create(&state_machine_output_thread, NULL, x1_state_machine_outputs, &global_data);
	pthread_create(&msg_srv_thread, NULL, x1_message_server_thread, &global_data);

	// Join on all threads (should never return a value however should handle anyway)
	pthread_join(sensor_thread, NULL);
	pthread_join(state_machine_thread, NULL);
	pthread_join(state_machine_output_thread, NULL);
	pthread_join(msg_srv_thread, NULL);

	printf("State Machine Node Ended\n");
	return EXIT_SUCCESS;
}

void* x1_message_server_thread(void* arg){

	sm_data_t* state_data = (sm_data_t*) arg;

	name_attach_t *attach;
	if ((attach = name_attach(NULL, ATTACH_POINT, 0)) == NULL){
		printf("\nFailed to name_attach on ATTACH_POINT: %s \n", ATTACH_POINT);
		printf("\n Possibly another server with the same name is already running !\n");
		return 0;
	}
	printf("Server Listening for Clients on ATTACH_POINT: %s \n", ATTACH_POINT);

	// Setup the sending and receiving message structs
	message_data_t msg;
	message_data_t msg_reply;
	msg_reply.hdr.type = 0x01;
	msg_reply.hdr.subtype = 0x00;


	int rcvid=0;
	while (1){
		// Receive any message
		rcvid = MsgReceive(attach->chid, &msg, sizeof(msg), NULL);

		// Message receive failed
		if (rcvid == -1){
			printf("\nFailed to MsgReceive\n");
			break;
		}

		// Determine the pulse code
		if(rcvid == 0){
			switch(msg.hdr.code){
				case _PULSE_CODE_DISCONNECT:
					printf("_PULSE_CODE_DISCONNECT\n");
					break;
				case _PULSE_CODE_UNBLOCK:
					printf("_PULSE_CODE_UNBLOCK");
					break;
				case _PULSE_CODE_COIDDEATH:
					printf("_PULSE_CODE_COIDDEATH");
					break;
				case _PULSE_CODE_THREADDEATH:
					printf("_PULSE_CODE_THREADDEATH");
					break;
				default:
					printf("Something else received\n");
					break;
			}
		continue;
		}
		if(rcvid > 0){
			printf("Message Received %d\n", msg.sending_node);
			msg_reply.sending_node = NODE_X1;
			msg_reply.receiving_node = msg.sending_node;
			msg_reply.msg_type = msg.msg_type;
			switch(msg.msg_type){
				case MSG_TRAIN_SIGNAL:
					printf("Signal Message Request\n");
					// Train is present in any state except 0
					sem_wait(&state_data->sem);
					if(&state_data->current_state){
					msg_reply.data = 1;
					}else{
					msg_reply.data = 0;
					}
					sem_post(&state_data->sem);
					break;
				case MSG_CURRENT_STATE:
					printf("Current State Request\n");
					sem_wait(&state_data->sem);
					msg_reply.data = state_data->current_state;
					sem_post(&state_data->sem);
					break;
				case MSG_CONTROL_STATE_LOCK:
					sem_wait(&state_data->sem);
					state_data->priority.last_state = state_data->current_state;
					state_data->priority.set = 1;
					state_data->priority.x1_reset = 1;
					sem_post(&state_data->sem);
					break;
				case MSG_CONTROL_STATE_RELEASE:
					sem_wait(&state_data->sem);
					sem_post(&state_data->sem);
					break;
				default:
					printf("Unknown Message Type\n");
					break;
			}
			MsgReply(rcvid, EOK, &msg_reply, sizeof(msg_reply));
		}
		else{
			printf("\nERROR: Server received something, but could not handle it correctly\n");
		}
	}
	// Remove the attach point name from the file system (i.e. /dev/name/local/<myname>)
	name_detach(attach, 0);
	return EXIT_SUCCESS;
}

/*
 * Thread to get char and send to x1 node. (will be replaced by a hardware thread)
 *
 */
void* sensor_send_thread(void* data){
	sm_data_t* sens_data = (sm_data_t*) data;

	// Main Loop
	while(1){
		char x = getchar();
		getchar(); // get the newline

		// Clear the sensor data except the latching boomgate sensor (only needed for sensor thread)
		sem_wait(&sens_data->sem);
		sens_data->signal &= (1 << X1_SIGNAL_BoomGateDown);
		sem_post(&sens_data->sem);

		switch(x){
			// East approching signal
			case 'e':

				sem_wait(&sens_data->sem);
				sens_data->sensor_received = 1;
				sens_data->signal |= 1 << X1_SIGNAL_Ein;
				sem_post(&sens_data->sem);

				printf("Train Approaching from the East\n");
				break;

			// East Leaving signal
			case 'd':

				sem_wait(&sens_data->sem);
				sens_data->sensor_received = 1;
				sens_data->signal |= 1 << X1_SIGNAL_Eout;
				sem_post(&sens_data->sem);

				printf("Train clear on the East line\n");
				break;
			// West Approaching signal
			case 'w':

				sem_wait(&sens_data->sem);
				sens_data->sensor_received = 1;
				sens_data->signal |= 1 << X1_SIGNAL_Win;
				sem_post(&sens_data->sem);

				printf("Train Approaching from the West\n");
				break;
			// West Departing signal
			case 's':

				sem_wait(&sens_data->sem);
				sens_data->sensor_received = 1;
				sens_data->signal |= 1 << X1_SIGNAL_Wout;
				sem_post(&sens_data->sem);

				printf("Train clear on the West line\n");
				break;
			// Boom gate down signal
			case 'b':

				sem_wait(&sens_data->sem);
				sens_data->sensor_received = 1;
				sens_data->signal |= 1 << X1_SIGNAL_BoomGateDown;
				sem_post(&sens_data->sem);

				printf("Boom gate down\n");
				break;
			// Boom gate up signal
			case 'u':

				sem_wait(&sens_data->sem);
				sens_data->sensor_received = 1;
				sens_data->signal &= ~(1 << X1_SIGNAL_BoomGateDown);
				sem_post(&sens_data->sem);

				printf("Boom gate up\n");
				break;
			default:
				printf("Unrecognised character, please try again\n");
				break;
		}
	}
}

/* Function to initialise the x1 global struct
 */
void x1_global_init(sm_data_t* data){
	data->current_state = X1_STATE_0;
	data->priority.last_state = X1_STATE_0;
	data->priority.set = 0;
	// Initialise the global semaphore
	sem_init(&data->sem, 0, 1);
	data->sensor_received = 0;
	data->signal = X1_SIGNAL_NONE;
}
