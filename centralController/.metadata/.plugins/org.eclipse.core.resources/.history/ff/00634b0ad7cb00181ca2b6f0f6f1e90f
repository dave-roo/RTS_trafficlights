#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <global_include.h>
#include <x1_include.h>
#include <i1_include.h>
#include <controller_include.h>

#define LOCAL_ATTACH_POINT "c1_group_14"

/*Function Declarations*/
void* c1_message_server_thread(void*);
void  c1_global_init(controller_data_t*);
void* software_output_thread(void*);
void* software_input_thread(void*);


int main(void) {
	// Create Global Struct
	controller_data_t global_data;
	c1_global_init(&global_data);

	// Setup the threads
	pthread_t c1_message_thread, output_thread, input_thread;
	pthread_create(&c1_message_thread, NULL, c1_message_server_thread, &global_data);
	pthread_create(&output_thread, NULL, software_output_thread, &global_data);
	pthread_create(&input_thread, NULL, software_input_thread, &global_data);

	pthread_join(output_thread, NULL);
	pthread_join(c1_message_thread, NULL);
	pthread_join(input_thread, NULL);
}

/* Controller Message Server Thread - This will handle all messages received from
 * the intersections and railway crossing. This will be responsible for receiving
 * state changes from any node and updating on the controller screen accordingly.
 * Arguments:
 * 	-> controller_data_t
 * @returns
 * 	-> Null
 */
void* c1_message_server_thread(void* arg){
	controller_data_t* controller_data = (controller_data_t*) arg;

	name_attach_t *attach;
	if ((attach = name_attach(NULL, LOCAL_ATTACH_POINT, 0)) == NULL){
		printf("\nFailed to name_attach on: %s \n", LOCAL_ATTACH_POINT);
		printf("\n Possibly another server with the same name is already running !\n");
		return 0;
	}
	printf("Server Listening for Clients on: %s \n", LOCAL_ATTACH_POINT);

	// Setup the sending and receiving message structs
	message_data_t msg;
	message_data_t msg_reply;
	msg_reply.sending_node = NODE_CONTROLLER;
	msg_reply.hdr.type = 0x01;
	msg_reply.hdr.subtype = 0x00;

	int rcvid=0;
	while (1){
		// Receive any message
		rcvid = MsgReceive(attach->chid, &msg, sizeof(msg), NULL);
		printf("B\n"); //debug
		// Message receive failed
		if (rcvid == -1){
			printf("\nFailed to MsgReceive\n");
			break;
		}

		// Determine the pulse code
		if(rcvid == 0){
			switch(msg.hdr.code){
				case _PULSE_CODE_DISCONNECT:
					printf("_PULSE_CODE_DISCONNECT\n");
					break;
				case _PULSE_CODE_UNBLOCK:
					printf("_PULSE_CODE_UNBLOCK");
					break;
				case _PULSE_CODE_COIDDEATH:
					printf("_PULSE_CODE_COIDDEATH");
					break;
				case _PULSE_CODE_THREADDEATH:
					printf("_PULSE_CODE_THREADDEATH");
					break;
				default:
					printf("Something else received\n");
					break;
			}
		continue;
		}
		if(rcvid > 0){
			//debug printf
			printf("Message received SENDING_NODE:%d TYPE:%d DATA:%d\n", msg.sending_node, msg.msg_type, msg.data);
			msg_reply.receiving_node = msg.sending_node;
			msg_reply.msg_type = msg.msg_type;

			/* TODO
			 * -> Update controller_data_t struct with intersection node state machine enums
			 * ->
			 */
			switch(msg.msg_type){
				// This is the only server message that the controller will respond to
				case MSG_CURRENT_STATE_UPDATE:
					// Update sending node current state enum
					// TODO this can definitely be coded better - possibly an array if time permits
					switch(msg.sending_node){
						case NODE_I1:
							// TODO
							printf("NODE_I1 Current State %d\n", msg.data);
							sem_wait(&controller_data->sem);
							controller_data->updated = 1;
							controller_data->i1_current_state = msg.data;
							sem_post(&controller_data->sem);
							break;
						case NODE_I2:
							// TODO
							sem_wait(&controller_data->sem);
							controller_data->updated = 1;
							printf("NODE_I2 Current State %d\n", msg.data);
							sem_post(&controller_data->sem);
							break;
						case NODE_X1:
							sem_wait(&controller_data->sem);
							controller_data->updated = 1;
							controller_data->x1_current_state = msg.data;
							sem_post(&controller_data->sem);
							break;
						default:
							msg_reply.msg_type = MSG_ERROR;
							msg_reply.data = MSG_BAD_REQUEST;
							break;
					}
					break;
				default:
					// If any other message is requested, reply with error
					msg_reply.msg_type = MSG_ERROR;
					msg_reply.data = MSG_BAD_REQUEST;
					break;
			}
			MsgReply(rcvid, EOK, &msg_reply, sizeof(msg_reply));
		}
		else{
			printf("\nERROR: Server received something, but could not handle it correctly\n");
		}
	}
	// Remove the attach point name from the file system (i.e. /dev/name/local/<myname>)
	name_detach(attach, 0);
	return (int*) EXIT_FAILURE;
}

/* Software thread that is to be replaced by hardware
 * Reads button presses and sends messages to other nodes
 *
 */
void* software_input_thread(void* arg){
	controller_data_t* controller_data = (controller_data_t*) arg;

	char* sending_name[3] = {X1_QNET_ATTACH_POINT, "I1_GLOBAL", "I2_GLOBAL"}; // TODO need to update these global names in the global include

	message_data_t msg;
	message_data_t msg_reply;

	msg_reply.msg_type = MSG_ERROR;
	msg_reply.msg_type = MSG_NO_VALID_RESPONSE;

	msg.sending_node = NODE_CONTROLLER;

	printf("Software input thread started on the controller\n");
	char x;
	while(1){
		printf("Please select option:\n");
		printf(" l -> Priority Traffic\n r -> Release Traffic Lock\n");
		x = getchar();
		while(getchar() != '\n'); // Get remaining characters and discard
		switch(x){
			case 'l':
				sem_wait(&controller_data->sem);
				controller_data->updated = 1;
				controller_data->priority.signal_sent = 1;
				sem_post(&controller_data->sem);
				msg.msg_type = MSG_CONTROL_STATE_LOCK;
				msg.data = 0;
				// Send to all nodes
				for(int i=0; i<3; i++){
					msg_reply = send_message(&msg, sending_name[i]);
					if(msg_reply.msg_type == MSG_ERROR){
						switch(msg_reply.data){
							case MSG_CONNECTION_ERROR:
								printf("Connection error to %s!\n", sending_name[i]);
								break;
							case MSG_SENDING_ERROR:
								printf("Message did not send to %s\n", sending_name[i]);
								break;
							case MSG_BAD_REQUEST:
								printf("%s rejected this message type\n", sending_name[i]);
								break;
							case MSG_NO_VALID_RESPONSE:
								printf("%s connected but did not respond\n", sending_name[i]);
								break;
							default:
								printf("Unknown Error when sending lock to %s!\n", sending_name[i]);
								break;
						}
					}else{
						printf("Successfully sent lock to %s\n", sending_name[i]);
					}
				}
				break;
			case 'r':
				sem_wait(&controller_data->sem);
				controller_data->updated = 1;
				controller_data->priority.signal_sent = 1;
				sem_post(&controller_data->sem);
				msg.msg_type = MSG_CONTROL_STATE_RELEASE;
				msg.data = 0;
				// Send to all nodes
				for(int i=0; i<3; i++){
					msg_reply = send_message(&msg, sending_name[i]);
					if(msg_reply.msg_type == MSG_ERROR){
						switch(msg_reply.data){
							case MSG_CONNECTION_ERROR:
								printf("Connection error to %s!\n", sending_name[i]);
								break;
							case MSG_SENDING_ERROR:
								printf("Message did not send to %s\n", sending_name[i]);
								break;
							case MSG_BAD_REQUEST:
								printf("%s rejected this message type\n", sending_name[i]);
								break;
							case MSG_NO_VALID_RESPONSE:
								printf("%s connected but did not respond\n", sending_name[i]);
								break;
							default:
								printf("Unknown Error when sending release to %s!\n", sending_name[i]);
								break;
						}
					}else{
						printf("Successfully sent release to %s\n", sending_name[i]);
					}
				}
				break;
			default:
				printf("Invalid Option\n\n");
				continue;
				break;
		}
	}
}


/* Software output thread - This needs to be replaced by a hardware output to LCD
 * Use the same structure that is here - eg cast global struct and wrap in sem_wait and post
 * to ensure data integrity
 */
void* software_output_thread(void* arg){
	printf("Begin Output Thread\n");
	controller_data_t* out_data = (controller_data_t*) arg;
	while(1){
		// Need to project global struct
		sem_wait(&out_data->sem);
		// Wait for struct to be updated
		if(out_data->priority.signal_sent){
			if(out_data->priority.i1_ready && out_data->priority.i2_ready && out_data->priority.x1_ready){
				printf("All states ready for priority traffic\n");
			}else if(out_data->updated){
				out_data->updated = 0;
				printf("I1 Status:%d I2 Status:%d X1 Status:%d\n", out_data->priority.i1_ready, out_data->priority.i2_ready, out_data->x1_current_state);

			}
		}else if(out_data->updated){
			out_data->updated = 0;
			printf("Would update screen here\n");
			printf("I1 Current State_%d", out_data->i1_current_state);
//			printf("I2 Current State_%d", out_data->i2_current_state);
			printf("X1 Current State_%d", out_data->x1_current_state);
		}
		sem_post(&out_data->sem);
	}
}


/* Function to initialise the controller global struct
 */
void c1_global_init(controller_data_t* data){
	data->x1_current_state = X1_STATE_0;
	data->i1_current_state = i1_State_0;
	data->updated = 0;
	// Initialise the global semaphore
	sem_init(&data->sem, 0, 1);
}
