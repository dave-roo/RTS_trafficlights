#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <global_include.h>
#include <x1_include.h>

#define LOCAL_ATTACH_POINT "c1_group_14"

void* c1_message_server_thread(void*);

int main(void) {
	pthread_t c1_message_thread;
	pthread_create(&c1_message_thread, NULL, c1_message_server_thread, NULL);

	pthread_join(c1_message_thread, NULL);

}

void* c1_message_server_thread(void* arg){
	name_attach_t *attach;
	if ((attach = name_attach(NULL, LOCAL_ATTACH_POINT, 0)) == NULL){
		printf("\nFailed to name_attach on: %s \n", LOCAL_ATTACH_POINT);
		printf("\n Possibly another server with the same name is already running !\n");
		return 0;
	}
	printf("Server Listening for Clients on: %s \n", LOCAL_ATTACH_POINT);

	// Setup the sending and receiving message structs
	message_data_t msg;
	message_data_t msg_reply;
	msg_reply.sending_node = NODE_CONTROLLER;
	msg_reply.hdr.type = 0x01;
	msg_reply.hdr.subtype = 0x00;

	int rcvid=0;
	while (1){
		// Receive any message
		rcvid = MsgReceive(attach->chid, &msg, sizeof(msg), NULL);

		// Message receive failed
		if (rcvid == -1){
			printf("\nFailed to MsgReceive\n");
			break;
		}

		// Determine the pulse code
		if(rcvid == 0){
			switch(msg.hdr.code){
				case _PULSE_CODE_DISCONNECT:
					printf("_PULSE_CODE_DISCONNECT\n");
					break;
				case _PULSE_CODE_UNBLOCK:
					printf("_PULSE_CODE_UNBLOCK");
					break;
				case _PULSE_CODE_COIDDEATH:
					printf("_PULSE_CODE_COIDDEATH");
					break;
				case _PULSE_CODE_THREADDEATH:
					printf("_PULSE_CODE_THREADDEATH");
					break;
				default:
					printf("Something else received\n");
					break;
			}
		continue;
		}
		if(rcvid > 0){
			printf("Message Received %d\n", msg.sending_node);
			msg_reply.receiving_node = msg.sending_node;
			msg_reply.msg_type = msg.msg_type;
			switch(msg.msg_type){
				case MSG_TRAIN_SIGNAL:
					printf("Signal Message Request\n");
					// Train is present in any state except 0
					sem_wait(&state_data->sem);
					if(&state_data->current_state){
					msg_reply.data = 1;
					}else{
					msg_reply.data = 0;
					}
					sem_post(&state_data->sem);
					break;
				case MSG_CURRENT_STATE:
					printf("Current State Request\n");
					sem_wait(&state_data->sem);
					msg_reply.data = state_data->current_state;
					sem_post(&state_data->sem);
					break;
				case MSG_CONTROL_STATE_LOCK:
					printf("Locking State\n");
					sem_wait(&state_data->sem);
					state_data->priority.set = 1;
					state_data->priority.x1_reset = 1;
					state_data->sensor_received = 1;
					sem_post(&state_data->sem);
					break;
				case MSG_CONTROL_STATE_RELEASE:
					printf("Releasing State\n");
					sem_wait(&state_data->sem);
					state_data->priority.set = 0;
					state_data->sensor_received = 1; // Notify the state machine that something happened (should be a cond var)
					sem_post(&state_data->sem);
					break;
				default:
					printf("Unknown Message Type\n");
					break;
			}
			MsgReply(rcvid, EOK, &msg_reply, sizeof(msg_reply));
		}
		else{
			printf("\nERROR: Server received something, but could not handle it correctly\n");
		}
	}
	// Remove the attach point name from the file system (i.e. /dev/name/local/<myname>)
	name_detach(attach, 0);
	return EXIT_SUCCESS;
}
